use std::fs::{OpenOptions, File};
use std::io::{self, Write, BufReader, BufRead};
use chrono::{Local, NaiveDate};

#[derive(Debug)]
struct Entry {
    date: NaiveDate,
    words: u32,
    time_spent: u32, // in minutes
    notes: String,
}

fn main() {
    let mut entries: Vec<Entry> = Vec::new();
    load_entries(&mut entries);

    loop {
        println!("Daily Writing Log\n==================");
        println!("1. Add a new entry");
        println!("2. View statistics");
        println!("3. Exit");

        let choice = get_user_input("Enter your choice: ");

        match choice.as_str() {
            "1" => add_new_entry(&mut entries),
            "2" => show_statistics(&entries),
            "3" => {
                save_entries(&entries);
                println!("Goodbye!");
                break;
            }
            _ => println!("Invalid choice, please try again."),
        }
    }
}

fn add_new_entry(entries: &mut Vec<Entry>) {
    let date = Local::now().date_naive();
    let words: u32 = get_user_input("Words written: ").parse().unwrap_or(0);
    let time_spent: u32 = get_user_input("Time spent (in minutes): ").parse().unwrap_or(0);
    let notes = get_user_input("Notes: ");

    let entry = Entry {
        date,
        words,
        time_spent,
        notes,
    };

    println!("Logged: {} - {} words, {} minutes", entry.date, entry.words, entry.time_spent);
    entries.push(entry);
}

fn show_statistics(entries: &[Entry]) {
    let total_words: u32 = entries.iter().map(|e| e.words).sum();
    let total_entries = entries.len();
    let total_time: u32 = entries.iter().map(|e| e.time_spent).sum();
    let streak = calculate_streak(entries);

    println!("\nStatistics:\n--------------------");
    println!("Total words written: {}", total_words);
    println!("Total entries logged: {}", total_entries);
    println!("Total time spent: {} minutes", total_time);
    println!("Current streak of consecutive writing days: {}\n", streak);
}

fn calculate_streak(entries: &[Entry]) -> u32 {
    if entries.is_empty() {
        return 0;
    }

    let mut streak = 1;
    let mut current_date = entries.last().unwrap().date;

    for entry in entries.iter().rev().skip(1) {
        if current_date.signed_duration_since(entry.date).num_days() == 1 {
            streak += 1;
            current_date = entry.date;
        } else {
            break;
        }
    }

    streak
}

fn save_entries(entries: &[Entry]) {
    let file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open("writing_log.txt")
        .unwrap();

    let mut writer = io::BufWriter::new(file);

    for entry in entries {
        writeln!(
            writer,
            "{}|{}|{}|{}",
            entry.date, entry.words, entry.time_spent, entry.notes
        )
        .unwrap();
    }
}

fn load_entries(entries: &mut Vec<Entry>) {
    let file = File::open("writing_log.txt");

    if let Ok(file) = file {
        let reader = BufReader::new(file);
        for line in reader.lines() {
            if let Ok(line) = line {
                let parts: Vec<&str> = line.split('|').collect();
                if parts.len() == 4 {
                    if let (Ok(date), Ok(words), Ok(time_spent)) = (
                        NaiveDate::parse_from_str(parts[0], "%Y-%m-%d"),
                        parts[1].parse(),
                        parts[2].parse(),
                    ) {
                        entries.push(Entry {
                            date,
                            words,
                            time_spent,
                            notes: parts[3].to_string(),
                        });
                    }
                }
            }
        }
    }
}

fn get_user_input(prompt: &str) -> String {
    print!("{}", prompt);
    io::stdout().flush().unwrap();
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    input.trim().to_string()
}

